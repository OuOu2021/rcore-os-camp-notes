## 汇编相关
### Program Counter
* 自动递增，每条指令后自增4
* 不能直接用于逻辑或算数计算，而是通过`jal`，`jalr`，`beq`，`bne`等命令间接修改它来控制程序流
### 寻址模式
* 理解：是指一条命令找到并利用操作数的四种方式，而不仅限于跳转命令。如算数指令的操作数可以来自寄存器、立即数，而从内存的话得先用`ld`等命令加载到寄存器才行
* `RISC-V`指令集的指令为32位长，理论上让跳转以字为单位可以方便扩展跳转范围，但实际上`PC`相对偏移(`jalr`、`jal`)以及条件分支(`bne`)的数值是以2字节(半字)为单位的

#### 立即数寻址
* 如`addi`
* 操作数是指令中的常量
#### 寄存器寻址
* 如`add`，`sub`
* 操作数是寄存器
#### 基址寻址
* 如`ld`，`sd`
* 操作数是指令中的常量+寄存器`offset`

#### PC相对寻址
* 如`jal`，`beq`等程序流控制命令
* 64位的`program counter`与较小的立即数`offset`相加来寻址，方便跳转到当前代码附近的区域，用于函数内的条件分支(`bne`，高级语言`if`语句，`+-2^10`)与无条件跳转(`jalr`，高级语言`循环`语句,`+-2^18`)
* 函数调用可能需要横跨很大范围，`jal`的`20`位立即数也可能不够。这时`lui`与`jalr`两个指令相加，可以跳转到任何`32`位地址：`lui`将地址的高20位写入寄存器，`jalr`将地址的低12位加到临时寄存器并跳转到目标位置。
	* 对于`64`位地址，要进行两次32位加载操作，第一次之后用`slli`左移32位，所以共5条命令

### 链接器
* 通过`ELF`中的重定位信息和符号表来解析标签，并替换为地址
#### 链接器工作流程
1. 将代码和数据模块以符号形式放在内存中
2. 决定数据和指令标签的地址（汇编时标签只是标签，还没有地址）
3. 修正内部与外部引用

### DLL延迟链接
* DLL在第一次调用时才通过动态加载器来进行链接加载，而后续调用则无需再经过动态加载器

### 调用约定
* 寄存器分为保存的和不保存的。这个“保存”与“不保存”是指**在过程内**需不需要保存。保存的由*被调用者*通过保存与恢复，来保证在调用前后不变；而不保存的不是任何时候都不保存，而是不由**被调用者**负责，而是在必要的时候（即：在调用过程后还需要使用 *不保存* 部分的数据）由*调用者*保存与恢复
	* `saved`是由被调用者保证调用前后不变
	* `sp`通过`addi`的压栈弹栈来保证调用前后不变。所以过程的栈帧大小在编译时需要是确定的
	* `fp/s0/x8`也是由调用者维护，在入栈时将原来的`fp`也入栈，然后更新`fp`，在弹栈恢复`sp`前先恢复`fp`
		* 单线程时不涉及存储和恢复栈帧操作，其实只需要`sp`而不需要`fp`也能正常工作。所以`llvm`默认会把`fp`当成一个参数寄存器用，`rusc`可以用`-C force-frame-pointers`编译参数强制维护和使用`fp`。`gcc`好像是相反，默认使用`fp`，通过`-fomit-frame-pointer`来优化掉`fp`
	* `ra`在非叶过程中需要调用者保存
	* `temporary registers`则是调用结束后用不着了，所以无需保证
	* 还有`arg/return registers`也是不保存的，但有可能在调用结束后还用得上，这时就要由调用者来保存，保证在调用后不被覆盖掉

| 保存（调用者需要保证调用前后不变）               | 不保存（调用者无需保证不变）                      |
| ------------------------------- | ----------------------------------- |
| saved registers: x8~x9, x18~x27 | temporary registers: x5~x7, x28~x31 |
| stack pointer: x2(sp)           | arg/return registers: x10~x17       |
| frame pointer: x8(fp)           |                                     |
| return address: x1(ra)          |                                     |
| 栈指针以上的栈                         | 栈指针以下的栈                             |

#### 实例
```rust
#[no_mangle]
#[inline(never)]
pub fn fact(n: i64) -> i64 {
    if n<1 {1}
    else {n*fact(n-1)}
}
```

```asm
fact:
        addi    sp, sp, -16
        sd      ra, 8(sp) 
        sd      s0, 0(sp)
        addi    s0, sp, 16    # 维护sp寄存器
        blez    a0, .LBB0_3
        li      a2, 1
        li      a1, 1
.LBB0_2:
        mv      a3, a0
        addi    a0, a0, -1
        mul     a1, a3, a1
        bltu    a2, a3, .LBB0_2
        j       .LBB0_4
.LBB0_3:
        li      a1, 1
.LBB0_4:
        mv      a0, a1
        ld      ra, 8(sp)
        ld      s0, 0(sp)    # 恢复fp寄存器为sp
        addi    sp, sp, 16
        ret
```